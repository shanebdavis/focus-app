import &StandardImport

maxSubtasks = 3

class Task extends ApplicationState

  @persistant()

  @stateFields
    root:
      text: "" (set your all-encompassing goal here)
      subtasks: []

  updateTask: (id, props) ->
    @setState
      id
      merge @state[id], props

  clearUnusedSubtasks: (exceptId)->
    newState = object task, taskId in @state when
      taskId == :root
      || taskId == exceptId
      || present task?.text

    each {subtasks}, taskId in newState when subtasks?.length > 0
      newState[taskId] = merge newState[taskId], subtasks:
        array subtaskId in subtasks when newState[subtaskId]

    @replaceState newState


  _removeTask: (id) ->
    if @state[id] extract? parentTaskId
      @setState id, null
      @updateTask
        parentTaskId
        subtasks: arrayWithoutValue @state[parentTaskId].subtasks, id

  complete: (id) ->
    @_removeTask id

  abandon: (id) ->
    @_removeTask id

  newSubtask: (parentTaskId) ->
    newSubtaskId = cryptoRandomString 10

    unless parentTask = @state[parentTaskId]
      throw new Error "invalid parentTaskId: #{parentTaskId}"

    unless !parentTask.subtasks || parentTask.subtasks.length < maxSubtasks
      throw new Error "invalid parentTask already has too many subtasks: #{parentTask.subtasks.length}"

    @setState
      [parentTaskId]: merge
        parentTask
        subtasks: compactFlattenAll parentTask.subtasks, newSubtaskId
      [newSubtaskId]: {}
        parentTaskId
        text: ''

    newSubtaskId