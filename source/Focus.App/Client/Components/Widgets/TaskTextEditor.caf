import &StandardImport

class TaskTextEditor extends FluxComponent
  @subscriptions
    :appKitViewState.gridSize
    :task

  @stateFields
    editingText: false

  @propFields :taskId

  updateTask: (mergeInTaskProps) ->
    @models.task.updateTask
      @taskId
      mergeInTaskProps

  valueChanged: ({props:{value}}) ->
    @updateTask
      text: value

  normalizeValue: ->
    @updateTask
      text:
        @task.text.trim()
        .replace /\n\n+/g,  "" \n
        .replace /[ \t]+/g,    ' '

  scrollOnScreen: ->
    @refs?.mainElement?.element?.scrollOnScreen()

  # NOTE - iOS only lets focus setting while in a touch-event
  # https://stackoverflow.com/questions/18728166/programmatically-focus-on-next-input-field-in-mobile-safari
  focusInput: ->
    @refs?.textInput?.element?.focus() # for iOS???
    timeout 10, ->
      @refs?.textInput?.element?.moveCursorToEnd()
      @refs?.textInput?.element?.focus()
    timeout 20, @scrollOnScreen
    timeout 300, @scrollOnScreen

  preprocessState: (state) ->
    if state.task && @props.taskId != :root && !present state.task.text
      @focusInput()
      merge super, editingText: true
    else
      super

  render: ->
    @ extract gridSize
    @props extract tight
    @task extract? text

    commonTextProps =
      switch @props.depth
      when 1 then TextStyles.xxLargeLightText
      when 2 then TextStyles.xLargeLightText
      else TextStyles.largeLightText
      padding:  gridSize * 2
      color:    TextPalette.black.primary
      maxLines: 3
      :textCenterCenter

    Element
      # draw: :red
      key: :mainElement
      on: unless @depth
        pointerClick: ->
          @triggerEditingText()
          @focusInput()

      Element
        :clip
        :centerCenter
        size: if @editingText then :parentSize else 0
        on:
          blur: ->
            unless present text
              @models.task.clearUnusedSubtasks()
            @clearEditingText()
          pointerClick: @focusInput

        :textCursor
        padding: gridSize * 2
        TextInputElement
          commonTextProps

          size:
            ww:   1
            hch:  1
            max:  hh: 1
          :parentWidthChildrenHeight if tight
          :centerCenter
          key:        :textInput
          maxLength:  60
          padding:    0
          captureWheelEvents: true
          type:   :textarea
          placeholder:
            if @taskId == :root
              "#1 goal"
            else
              "sub-goal"
          value:  text
          on: {}
            focus:  @triggerEditingText
            blur:   @normalizeValue
            # enter:  @clearEditingText
            @valueChanged

      unless @editingText
        TextElement
          commonTextProps
          :textCursor
          :parentSize
          text: text
