import &StandardImport

class Task extends FluxComponent
  @subscriptions
    :appKitViewState.gridSize
    :task

  @propFields :taskId

  @stateFields
    editingText:                  false
    axisXOffset:                  0
    tracking:                     false
    falling:                      false
    absoluteXOffset:              0
    swipeWillActivate:            0
    swipeWillActivateDirection:   null

  swipeRight: -> @models.task.complete @taskId
  swipeLeft:  -> @models.task.abandon  @taskId

  @getter
    handlers: ->
      swipeDistanceThreshold = 100
      @_handlers ?= createGestureRecognizer
        flick: ({props:{flickDirection}}) ->
          switch flickDirection
          when :right then @swipeRight()
          when :left  then @swipeLeft()

        horizontal:
          begin: (e) ->
          move:  (e) ->
            @tracking = true
            # timeout 100, -> @tracking = false
            @absoluteXOffset = x = e.totalParentDelta.x
            @axisXOffset = -e.totalParentDelta.x / e.target.currentSize.x
            @swipeWillActivate = min 1, if x > 0
              @swipeWillActivateDirection = :left
              x / swipeDistanceThreshold
            else
              @swipeWillActivateDirection = :right
              -x / swipeDistanceThreshold

          end:   (e) ->
            activate = false
            switch
              when @absoluteXOffset < -swipeDistanceThreshold then activate = true;@swipeLeft()
              when @absoluteXOffset >  swipeDistanceThreshold then activate = true;@swipeRight()
            if activate
              @axisXOffset *= 2
              @falling = true
            else
              @axisXOffset = 0

          finally: @clearTracking

          cancel: (e) ->
            @axisXOffset = 0

  focusInput: ->
    @refs?.textInput?.element?.focus() # for iOS???
    timeout 10, @refs?.textInput?.element?.focus()

  preprocessState: (state) ->
    if state.task && @props.taskId != :root && !present state.task.text
      merge super, editingText: true
    else
      super

  render: ->
    @ extract gridSize, tracking
    @task extract?
      text
      subtasks

    subtasks ?= []

    Element
      :parentWidthSquare

      animators:
        opacity:
          d: .5
          f: :easeOutQuart
          toFrom: 0

        location:
          f: :easeOutQuad
          d: .5
          to: yh: 1

      Element
        :column
        :bottomCenter
        :cacheDraw

        draw:
          radius:     5
          color:      :white

        animators:
          opacity:
            toFrom:   0
            duration: 1

          axis:
            if @falling
              f: :easeOutQuad
              d: .5
            else
              !tracking
          angle:
            if @falling
              f: :easeOutQuad
              d: .5
            else
              !tracking

        on: if @props.depth > 1 then @handlers

        axis:
          y: 1
          x: .5 + @axisXOffset / 2
        angle: -@axisXOffset / 2# / 200


        TextElement
          TextStyles.largeBoldItalicText
          color: AppPalette.green
          padding: gridSize
          text: "" #{@props.depth}
          inFlow: false

        TaskTextEditor {} @taskId, @props.depth

        Element
          size: h: 1
          draw: AppPalette.green

        Element
          layoutWeight: .5
          :row

          array i til 3
            if taskId = subtasks[i]
              SubtaskButton {} taskId, parentTaskId: @taskId
            else
              NewSubtaskButton {} @taskId

      if !floatEq0 @axisXOffset
        Element
          :centerCenter
          :childrenSize
          draw:
            radius: 100
            if @swipeWillActivate >= 1
              AppPalette.green
            else
              AppPalette.grey
          key: :actionMessage
          padding: @gridSize
          animators:
            :draw
            scale:
              if @swipeWillActivate >= 1
                f: :easeInElastic
                d: .5
              else
                f: :easeInQuad
            opacity: toFrom: 0
          scale:
            if @swipeWillActivate >= 1
              2
            else
              1 + .5 * @swipeWillActivate

          TextElement
            TextStyles.smallBoldText
            :childrenSize

            color: TextPalette.white.primary
            # opacity: @swipeWillActivate

            text:
              switch @swipeWillActivateDirection
              when :right then :abandon
              when :left  then :complete
