import &StandardImport

class Task extends FluxComponent
  @subscriptions
    :appKitViewState.gridSize
    :task

  @propFields :taskId

  @stateFields
    editingText: false
    axisXOffset: 0
    tracking:    false
    falling:    false
    absoluteXOffset: 0
    swipeWillActivate: 0
    swipeWillActivateDirection: null

  swipeRight: ->
    @models.task.complete @taskId

  swipeLeft: ->
    @models.task.abandon @taskId

  @getter
    handlers: ->
      swipeDistanceThreshold = 100
      @_handlers ?= createGestureRecognizer
        flick: ({props:{flickDirection}}) ->
          switch flickDirection
          when :right then @swipeRight()
          when :left  then @swipeLeft()

        horizontal:
          begin: (e) ->
          move:  (e) ->
            @tracking = true
            # timeout 100, -> @tracking = false
            @absoluteXOffset = x = e.totalParentDelta.x
            @axisXOffset = -e.totalParentDelta.x / e.target.currentSize.x
            @swipeWillActivate = min 1, if x > 0
              @swipeWillActivateDirection = :left
              x / swipeDistanceThreshold
            else
              @swipeWillActivateDirection = :right
              -x / swipeDistanceThreshold

          end:   (e) ->
            activate = false
            switch
              when @absoluteXOffset < -swipeDistanceThreshold then activate = true;@swipeLeft()
              when @absoluteXOffset >  swipeDistanceThreshold then activate = true;@swipeRight()
            if activate
              @axisXOffset *= 2
              @falling = true
            else
              @axisXOffset = 0
              @tracking = false

          cancel: (e) ->
            @axisXOffset = 0
            @tracking = false

  updateTask: (mergeInTaskProps) ->
    @models.task.updateTask
      @taskId
      mergeInTaskProps

  valueChanged: ({props:{value}}) ->
    @updateTask text: value.trim()

  newSubtask: ->
    @models.taskNavState.showSubtask
      @taskId
      newSubtaskId = @models.task.newSubtask @taskId

  focusInput: -> timeout 10, @refs?.textInput?.element?.focus()

  preprocessState: (state) ->
    if state.task && !present state.task.text
      merge super, editingText: true
    else
      super

  render: ->
    @ extract gridSize
    @task extract?
      text
      subtasks

    subtasks ?= []

    MainTextElementType = (if @editingText then TextInputElement else TextElement)

    commonTextProps =
      switch @props.depth
      when 1 then TextStyles.xxLargeLightText
      when 2 then TextStyles.xLargeLightText
      else TextStyles.largeLightText
      padding:  @gridSize * 2
      color:    TextPalette.black.softPrimary
      :textCenterCenter

    Element
      :parentWidthSquare

      animators:
        opacity:
          d: .5
          f: :easeOutQuart
          toFrom: 0

        location:
          f: :easeOutQuad
          d: .5
          to: yh: 1


      Element
        :column
        :bottomCenter
        :cacheDraw

        draw:
          radius:     5
          color:      :white

        animators:
          opacity:
            toFrom:   0
            duration: 1

          axis:
            if @falling
              f: :easeOutQuad
              d: .5
            else
              !@tracking
          angle:
            if @falling
              f: :easeOutQuad
              d: .5
            else
              !@tracking

        on: if @props.depth > 1 then @handlers

        axis:
          y: 1
          x: .5 + @axisXOffset / 2
        angle: -@axisXOffset / 2# / 200


        TextElement
          TextStyles.largeBoldItalicText
          color: AppPalette.green
          padding: gridSize
          text: "" #{@props.depth}
          inFlow: false

        if @editingText
          Element
            on:
              blur: ->
                unless present text
                  @models.task.clearUnusedSubtasks()
                @clearEditingText()
              pointerClick: ->
                @refs.textInput.element.focus()
            :textCursor
            TextInputElement
              commonTextProps
              size:
                ww: 1
                hch: 1
                max: hh: 1
              # :centerCenter
              key: "textInput"
              maxLength: 60
              captureWheelEvents: true
              # size:
                # ww:   1
                # hch:  1
                # max:  hh: 1
              type:   :textarea
              placeholder: "(new task)"
              value:  text
              on: {}
                enter: @clearEditingText
                @valueChanged
                ready: ({target}) ->
                  timeout 10 ->
                    target.focus()
            Element
              :bottomRight
              size:
                h: @gridSize * 3
                ww: 1/3

              draw:
                radius: 100
                padding: @gridSize / 2
                AppPalette.green

              ButtonWrapper
                action: @clearEditingText
                TextElement
                  TextStyles.mediumBoldText
                  color: TextPalette.white.primary
                  :parentSize
                  :textCenterCenter
                  text: "done"
        else
          TextElement
            commonTextProps
            :textCursor
            :parentSize
            text: text
            on: pointerClick: ->
              @triggerEditingText()
              timeout 10 @focusInput

        Element
          size: h: 1
          draw: AppPalette.green

        Element
          layoutWeight: .5
          :row

          array i til 3
            if taskId = subtasks[i]
              SubtaskButton {} taskId, parentTaskId: @taskId
            else
              NewSubtaskButton {} @taskId

      if !floatEq0 @axisXOffset
        Element
          :centerCenter
          :childrenSize
          draw:
            radius: 100
            if @swipeWillActivate >= 1
              AppPalette.green
            else
              AppPalette.grey
          key: :actionMessage
          padding: @gridSize
          animators:
            :draw
            scale:
              if @swipeWillActivate >= 1
                f: :easeInElastic
                d: .5
              else
                f: :easeInQuad
            opacity: toFrom: 0
          scale:
            if @swipeWillActivate >= 1
              2
            else
              1 + .5 * @swipeWillActivate

          TextElement
            TextStyles.smallBoldText
            :childrenSize

            color: TextPalette.white.primary
            # opacity: @swipeWillActivate

            text:
              switch @swipeWillActivateDirection
              when :right then :abandon
              when :left  then :complete
